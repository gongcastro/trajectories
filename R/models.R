#' Specify and sample a [brms::brm()] model
#' @param name A character string indicating the name to be assigned to the model
#' @param ... Arguments to be passed to [brms::brm()]
fit_model <- function(name, ...) {
  fit <- brms::brm(...,
    iter = 2e3L,
    chains = 4,
    init = 0.5,
    seed = 888,
    backend = "cmdstanr",
    file = glue::glue("results/{name}.rds"),
    control = list(adapt_delta = 0.9, max_treedepth = 15)
  )

  return(fit)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [tidybayes::gather_draws()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [tidybayes::gather_draws()].
get_posterior_draws <- function(model, data, vars_dict, ...) {
  # posterior draws
  posterior_draws <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE) |>
    mutate(
      .variable_name = factor(.variable,
        levels = names(vars_dict),
        labels = vars_dict
      ) |>
        as.character(),
      type = ifelse(
        grepl("Intercept", .variable),
        glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
        "Slopes"
      ),
      parameter = ifelse(
        grepl("Intercept", .variable),
        gsub("Intercept \\(|\\)", "", .variable),
        .variable
      )
    ) |>
    select(.variable, .variable_name,
      .type = type,
      .chain, .iteration, .draw, .value
    ) |>
    ungroup()

  save_files(posterior_draws,
    formats = "csv",
    folder = "results/"
  )

  return(posterior_draws)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [bayestesteR::describe_posterior()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [bayestesteR::describe_posterior()].
get_posterior_summary <- function(model,
                                  data,
                                  vars_dict,
                                  rope_interval = c(lower = -0.1, upper = +0.1),
                                  ...) {
  # posterior draws
  posterior_summary <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE, ...) |>
    tidybayes::median_hdci() |>
    mutate(
      .variable_name = factor(
        .variable,
        levels = names(vars_dict),
        labels = vars_dict,
        ordered = TRUE
      ),
      type = ifelse(
        grepl("Intercept", .variable),
        glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
        "Slopes"
      ),
      parameter = ifelse(
        grepl("Intercept", .variable),
        gsub("Intercept \\(|\\)", "", .variable),
        .variable
      ),
      .rope = get_rope_overlap(.lower, .upper, .rope = rope_interval),
      .rope = ifelse(grepl("Intercept", .variable), NA, .rope)
    ) |>
    arrange(type, .variable_name) |>
    select(.variable, .variable_name,
      .type = type,
      .value, .lower, .upper, .rope
    ) |>
    ungroup()

  return(posterior_summary)
}



#' Get model R-hat scores
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [bayesplot::rhat()] and
#' [bayesplot::neff_ratio()].
#'
#' @returns A [tibble::tibble] with three columns:
#' * .variable: parameter names, as returned by [brms::variables()]
#' * .rhat: R-hat (Gelman-Rubin) convergence diagnostic, as returned by
#' [bayesplot::rhat()].
#' * .neff: effective sample size, as returned by [bayesplot::neff_ratio()]
get_model_convergence <- function(model, ...) {
  tibble::tibble(
    .variable = variables(model),
    .rhat = rhat(model, ...),
    .neff = neff_ratio(model, ...)
  )
}

#' Get model posterior predictive checks
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [brms::posterior_predict()].
#'
get_model_ppc <- function(model, ...) {
  brms::posterior_predict(model, ndraws = 100, cores = 4)
}

#' Get overlap between an intervals and a ROPE
#'
#' @param .lower A numeric vector indicating the lower limit of the interval to contrasts against the ROPE
#' @param .upper A numeric vector indicating the upper limit of the interval to contrasts against the ROPE
#' @param .rope A numeric vector of length two indicating the limits of the region of practical equivalents against which the interval should be tested
#' @param precision A numeric vector of length one indicating the number of values each interval should be broke down into in order to compute the proportion of overlap
#' @returns A numeric vector of length `length(.lower)` indicating the proportion of overlap between the interval and the ROPE
#'
get_rope_overlap <- function(.lower, .upper, .rope = c(-0.1, 0.1), precision = 1e4) {
  int <- data.frame(.lower, .upper)
  fun <- \(x) approx(x, n = precision, method = "linear")
  int.seq <- purrr::map(apply(int, fun, MARGIN = 1), "y")
  overlap <- purrr::map_dbl(int.seq, \(x) mean((x >= .rope[1]) & x <= .rope[2]))
  return(overlap)
}

#' Generate dataset with posterior predictions from a brmsfit model
#'
#' @param model A brmsfit object
#'
#' @param data Data with which the model was fist, containing the original variables
#'
#' @param group Group for which posterior predictions will be generated:
#' * `NULL` (default): posterior predictions will be generated for fixed effect.
#' * `"te"`: posterior predictions will be generated for translation equivalents.
#' * `"id"`: posterior predictions will be generated for participants.
#' @param levels If group is `"te"` or `"id"`, specific levels (translation equivalents or participants) can be specified. If NULL (default), posterior predictions are generated for all levels of the grouping variable.
#' @inheritParams marginaleffects::datagrid
#'
generate_newdata <- function(model, group = NULL, levels = NULL, ...) {
  # validate data
  is.data.provided <- length(list(...)) > 0
  if (!is.data.provided) {
    cli::cli_abort("Predictor values must be provided")
  }

  # validate group variable names
  grouping.vars <- names(brms::ranef(model))
  if (!is.null(group)) {
    if (!(group %in% grouping.vars) | length(group) > 1) {
      cli::cli_abort("group must be one of {grouping.vars}")
    }
  }

  # make sure that all levels exist in the dataset
  if (!is.null(levels)) {
    levels_in_data <- levels %in% model[["data"]][[group]]
    if (!all(levels_in_data)) {
      missing_levels <- paste0(levels[!levels_in_data], collapse = ", ")
      cli::cli_abort("Level {missing_levels} in {.field {group}} is missing")
    }
  }

  # data frame with prediction combinations
  if (is.null(group)) {
    nd <- expand_grid(te = NA, id = NA, ...)
  } else {
    # expand predictor levels in data frame to generate predictions
    if (group == "te") {
      # if group is "te", generate predictions for each level of `te`
      nd <- expand_grid(te = levels, id = NA, ...) |>
        select(-lv_std) |>
        left_join(distinct(data, te, lv_std))
    }
    if (group == "id") {
      # expand predictor levels in data frame to generate predictions
      nd <- expand_grid(id = levels, te = NA, ...) |>
        select(-age_std) |>
        left_join(distinct(data, id, age_std))
    }
  }

  return(nd)
}



#' Generate expected posterior predictions for fixed effects brmsfit model via [tidybayes::add_epred_draws()]
#'
#' @param model A brmsfit object
#' @param ndraws Number of posterior draws to use
#' @inheritParams tidybayes::add_epred_draws
posterior_epreds <- function(model, ndraws = NULL, ...) {
  # generate data for predictions
  newdata <- generate_newdata(model, ...)

  # use marginaleffects to get posterior means
  predictions <- tidybayes::add_epred_draws(model,
    newdata = newdata,
    re_formula = NA,
    ndraws = ndraws,
    value = ".value"
  ) |>
    filter(.category != "No") |>
    pivot_wider(
      id_cols = any_of(c(".draw", colnames(newdata))),
      names_from = .category,
      values_from = .value
    ) |>
    mutate(`Understands` = `Understands and Says` + `Understands`) |>
    pivot_longer(c(`Understands`, `Understands and Says`),
      names_to = ".category",
      values_to = ".value"
    )

  # save predictions as Parquet file
  save_files(predictions,
    formats = "csv",
    folder = "results/"
  )

  return(predictions)
}
